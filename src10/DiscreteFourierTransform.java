/*
 * Copyright 1999-2004 Carnegie Mellon University.  
 * Portions Copyright 2002-2004 Sun Microsystems, Inc.  
 * Portions Copyright 2002-2004 Mitsubishi Electric Research Laboratories.
 * All Rights Reserved.  Use is subject to license terms.
 * 
 * See the file "license.terms" for information on usage and
 * redistribution of this file, and for a DISCLAIMER OF ALL 
 * WARRANTIES.
 *
 */
package cclo;

import edu.cmu.sphinx.frontend.BaseDataProcessor;
import edu.cmu.sphinx.frontend.Data;
import edu.cmu.sphinx.frontend.DataProcessingException;
import edu.cmu.sphinx.frontend.DoubleData;
import edu.cmu.sphinx.util.Complex;
import edu.cmu.sphinx.util.props.*;
import java.awt.BorderLayout;
import java.awt.Canvas;
import java.awt.Color;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.*;
import javax.swing.JOptionPane;
import javax.swing.Timer;
import net.sf.json.JSONArray;
import net.sf.json.JSONObject;

/**
 * Computes the Discrete Fourier Transform (FT) of an input sequence, using Fast
 * Fourier Transform (FFT). Fourier Transform is the process of analyzing a
 * signal into its frequency components. In speech, rather than analyzing the
 * signal over its entire duration, we analyze one <b>window</b> of audio data.
 * This window is the product of applying a sliding Hamming window to the
 * signal. Moreover, since the amplitude is a lot more important than the phase
 * for speech recognition, this class returns the power spectrum of that window
 * of data instead of the complex spectrum. Each value in the returned spectrum
 * represents the strength of that particular frequency for that window of data.
 * <p/>
 * By default, the number of FFT points is the closest power of 2 that is equal
 * to or larger than the number of samples in the incoming window of data. The
 * FFT points can also be set by the user with the property defined by {@link
 * #PROP_NUMBER_FFT_POINTS}. The length of the returned power spectrum is the
 * number of FFT points, divided by 2, plus 1. Since the input signal is real,
 * the FFT is symmetric, and the information contained in the whole vector is
 * already present in its first half.
 * <p/>
 * Note that each call to {@link #getData() getData} only returns the spectrum
 * of one window of data. To display the spectrogram of the entire original
 * audio, one has to collect all the spectra from all the windows generated from
 * the original data. A spectrogram is a two dimensional representation of three
 * dimensional information. The horizontal axis represents time. The vertical
 * axis represents the frequency. If we slice the spectrogram at a given time,
 * we get the spectrum computed as the short term Fourier transform of the
 * signal windowed around that time stamp. The intensity of the spectrum for
 * each time frame is given by the color in the graph, or by the darkness in a
 * gray scale plot. The spectrogram can be thought of as a view from the top of
 * a surface generated by concatenating the spectral vectors obtained from the
 * windowed signal.
 * <p/>
 * For example, Figure 1 below shows the audio signal of the utterance "one
 * three nine oh", and Figure 2 shows its spectrogram, produced by putting
 * together all the spectra returned by this FFT. Frequency is on the vertical
 * axis, and time is on the horizontal axis. The darkness of the shade
 * represents the strength of that frequency at that point in time:
 * <p>
 * <br><img
 * src="doc-files/139o.jpg"> <br><b>Figure 1: The audio signal of the utterance
 * "one three nine oh".</b>
 * <p>
 * <br><img src="doc-files/139ospectrum.jpg">
 * <br><b>Figure 2: The spectrogram of the utterance "one three nine oh" in
 * Figure 1.</b>
 */
public class DiscreteFourierTransform extends BaseDataProcessor implements Share {

    final int FFTNo = 1024;
    static int ratio = 0;
    /**
     * The property for the number of points in the Fourier Transform.
     */
    @S4Integer(defaultValue = -1)
    public static final String PROP_NUMBER_FFT_POINTS = "numberFftPoints";
    /**
     * The property for the invert transform.
     */
    @S4Boolean(defaultValue = false)
    public static final String PROP_INVERT = "invert";
    private boolean isNumberFftPointsSet;
    private int numberFftPoints;
    private int logBase2NumberFftPoints;
    private int numberDataPoints;
    private boolean invert;
    private Complex[] weightFft;
    private Complex[] inputFrame;
    private Complex[] from;
    private Complex[] to;
    private Complex weightFftTimesFrom2;
    private Complex tempComplex;

    public DiscreteFourierTransform(int numberFftPoints, boolean invert) {
        initLogger();
        this.numberFftPoints = numberFftPoints;
        this.isNumberFftPointsSet = (numberFftPoints != -1);
        this.invert = invert;
    }

    public DiscreteFourierTransform() {
    }

    /*
     * (non-Javadoc)
     *
     * @see
     * edu.cmu.sphinx.util.props.Configurable#newProperties(edu.cmu.sphinx.util.props.PropertySheet)
     */
    ActionListener hisTimerHandler = new ActionListener() {

        @Override
        public void actionPerformed(ActionEvent e) {
        }
    };

    @Override
    public void newProperties(PropertySheet ps) throws PropertyException {
        super.newProperties(ps);
        logger = ps.getLogger();
        numberFftPoints = ps.getInt(PROP_NUMBER_FFT_POINTS);
        isNumberFftPointsSet = (numberFftPoints != -1);
        invert = ps.getBoolean(PROP_INVERT);
    }


    /*
     * (non-Javadoc) @see
     * edu.cmu.sphinx.frontend.DataProcessor#initialize(edu.cmu.sphinx.frontend.CommonConfig)
     */
    @Override
    public void initialize() {
        super.initialize();
        if (isNumberFftPointsSet) {
            initializeFFT();
        }
    }

    /**
     * Initialize all the data structures necessary for computing FFT.
     */
    private void initializeFFT() {
        /**
         * Number of points in the FFT. By default, the value is 512, which
         * means that we compute 512 values around a circle in the complex
         * plane. Complex conjugate pairs will yield the same power, therefore
         * the power produced by indices 256 through 511 are symmetrical with
         * the ones between 1 and 254. Therefore, we need only return values
         * between 0 and 255.
         */
        computeLogBase2(numberFftPoints);
        createWeightFft(numberFftPoints, invert);
        initComplexArrays();
        weightFftTimesFrom2 = new Complex();
        tempComplex = new Complex();
    }

    /**
     * Initialize all the Complex arrays that will be necessary for FFT.
     */
    private void initComplexArrays() {

        inputFrame = new Complex[numberFftPoints];
        from = new Complex[numberFftPoints];
        to = new Complex[numberFftPoints];

        for (int i = 0; i < numberFftPoints; i++) {
            inputFrame[i] = new Complex();
            from[i] = new Complex();
            to[i] = new Complex();
        }
    }

    /**
     * Process data, creating the power spectrum from an input frame.
     *
     * @param input the input frame
     * @return a DoubleData that is the power spectrum of the input frame
     * @throws java.lang.IllegalArgumentException
     *
     */
    private DoubleData process(DoubleData input)
            throws IllegalArgumentException {

        /**
         * Create complex input sequence equivalent to the real input sequence.
         * If the number of points is less than the window size, we incur in
         * aliasing. If it's greater, we pad the input sequence with zeros.
         */
        double[] in = input.getValues();

        if (numberFftPoints < in.length) {
            int i = 0;
            for (; i < numberFftPoints; i++) {
                inputFrame[i].set(in[i], 0.0f);
            }
            for (; i < in.length; i++) {
                tempComplex.set(in[i], 0.0f);
                inputFrame[i % numberFftPoints].addComplex(inputFrame[i % numberFftPoints], tempComplex);
            }
        } else {
            int i = 0;
            for (; i < in.length; i++) {
                inputFrame[i].set(in[i], 0.0f);
            }
            for (; i < numberFftPoints; i++) {
                inputFrame[i].reset();
            }
        }

        /**
         * Create output sequence.
         */
        double[] outputSpectrum = new double[(numberFftPoints >> 1) + 1];

        /**
         * Start Fast Fourier Transform recursion
         */
        recurseFft(inputFrame, outputSpectrum, numberFftPoints, invert);

        /**
         * Return the power spectrum
         */
        DoubleData output = new DoubleData(outputSpectrum, input.getSampleRate(),
                input.getCollectTime(),
                input.getFirstSampleNumber());

        return output;
    }

    /**
     * Make sure the number of points in the FFT is a power of 2 by computing
     * its log base 2 and checking for remainders.
     *
     * @param numberFftPoints number of points in the FFT
     * @throws java.lang.IllegalArgumentException
     *
     */
    private void computeLogBase2(int numberFftPoints)
            throws IllegalArgumentException {
        this.logBase2NumberFftPoints = 0;
        for (int k = numberFftPoints; k > 1;
                k >>= 1, this.logBase2NumberFftPoints++) {
            if (((k % 2) != 0) || (numberFftPoints < 0)) {
                throw new IllegalArgumentException("Not a power of 2: "
                        + numberFftPoints);
            }
        }
    }

    /**
     * Initializes the <b>weightFft[]</b> vector.
     * <p>
     * <b>weightFft[k] = w ^ k</b></p> where:
     * <p>
     * <b>w = exp(-2 * PI * i / N)</b></p>
     * <p>
     * <b>i</b> is a complex number such that <b>i * i = -1</b> and <b>N</b> is
     * the number of points in the FFT. Since <b>w</b> is complex, this is the
     * same as</p>
     * <p>
     * <b>Re(weightFft[k]) = cos ( -2 * PI * k / N)</b></p>
     * <p>
     * <b>Im(weightFft[k]) = sin ( -2 * PI * k / N)</b></p>
     *
     * @param numberFftPoints number of points in the FFT
     * @param invert whether it's direct (false) or inverse (true) FFT
     */
    private void createWeightFft(int numberFftPoints, boolean invert) {
        /**
         * weightFFT will have numberFftPoints/2 complex elements.
         */
        weightFft = new Complex[numberFftPoints >> 1];

        /**
         * For the inverse FFT, w = 2 * PI / numberFftPoints;
         */
        double w = -2 * Math.PI / numberFftPoints;
        if (invert) {
            w = -w;
        }

        for (int k = 0; k < (numberFftPoints >> 1); k++) {
            weightFft[k] = new Complex(Math.cos(w * k), Math.sin(w * k));
        }
    }

    /**
     * Reads the next DoubleData object, which is a data frame from which we'll
     * compute the power spectrum. Signal objects just pass through unmodified.
     *
     * @return the next available power spectrum DoubleData object, or null if
     * no Spectrum object is available
     * @throws DataProcessingException if there is a processing error
     */
    @Override
    public Data getData() throws DataProcessingException {

        Data input = getPredecessor().getData();

        getTimer().start();

        if ((input != null) && (input instanceof DoubleData)) {
            DoubleData data = (DoubleData) input;
            if (!isNumberFftPointsSet) {
                /*
                 * If numberFftPoints is not set by the user, figure out the
                 * numberFftPoints and initialize the data structures
                 * appropriately.
                 */
                if (numberDataPoints != data.getValues().length) {
                    numberDataPoints = data.getValues().length;
                    numberFftPoints = getNumberFftPoints(numberDataPoints);
                    initializeFFT();
                }
            } else {
                /*
                 * Warn if the user-set numberFftPoints is not ideal.
                 */
                if (numberDataPoints != data.getValues().length) {
                    numberDataPoints = data.getValues().length;
                    int idealFftPoints = getNumberFftPoints(numberDataPoints);
                    if (idealFftPoints != numberFftPoints) {
                        logger.warning("User set numberFftPoints ("
                                + numberFftPoints + ") is not ideal ("
                                + idealFftPoints + ')');
                    }
                }
            }

            input = process(data);
            //*************** grab the output of FFT by cclo / every 0.01 sec FFTNo double frequency data ********************
            DoubleData output = (DoubleData) input;
            double cc[] = output.getValues();
            voice_Process(cc);
            if (pMain.binaryControl == 0 && pMain.finishRec) {
                throw new DataProcessingException("使用者輸入完成，開始搜尋");
            }
        }

        // At this point - or in the call immediatelly preceding
        // this -, we should have created a cepstrum frame with
        // whatever data came last, even if we had less than
        // window size of data.
        getTimer().stop();

        return input;
    }

    /**
     * Returns the ideal number of FFT points given the number of samples. The
     * ideal number of FFT points is the closest power of 2 that is equal to or
     * larger than the number of samples in the incoming window.
     *
     * @param numberSamples the number of samples in the incoming window
     * @return the closest power of 2 that is equal to or larger than the number
     * of samples in the incoming window
     */
    private static int getNumberFftPoints(int numberSamples) {
        int fftPoints = 1;

        while (fftPoints < numberSamples) {
            fftPoints <<= 1;
            if (fftPoints < 1) {
                throw new Error("Invalid # of FFT points: " + fftPoints);
            }
        }
        return fftPoints;
    }

    /**
     * Establish the recursion. The FFT computation will be computed by as a
     * recursion. Each stage in the butterfly will be fully computed during
     * recursion. In fact, we use the mechanism of recursion only because it's
     * the simplest way of switching the "input" and "output" vectors. The
     * output of a stage is the input to the next stage. The butterfly computes
     * elements in place, but we still need to switch the vectors. We could copy
     * it (not very efficient...) or, in C, switch the pointers. We can avoid
     * the pointers by using recursion.
     *
     * @param input input sequence
     * @param output output sequence
     * @param numberFftPoints number of points in the FFT
     * @param invert whether it's direct (false) or inverse (true) FFT
     */
    private void recurseFft(Complex[] input,
            double[] output,
            int numberFftPoints,
            boolean invert) {

        double divisor;

        /**
         * The direct and inverse FFT are essentially the same algorithm, except
         * for two difference: a scaling factor of "numberFftPoints" and the
         * signal of the exponent in the weightFft vectors, defined in the
         * method <code>createWeightFft</code>.
         */
        if (!invert) {
            divisor = 1.0;
        } else {
            divisor = (double) numberFftPoints;
        }

        /**
         * Initialize the "from" and "to" variables.
         */
        for (int i = 0; i < numberFftPoints; i++) {
            to[i].reset();
            from[i].scaleComplex(input[i], divisor);
        }

        /**
         * Repeat the recursion log2(numberFftPoints) times, i.e., we have
         * log2(numberFftPoints) butterfly stages.
         */
        butterflyStage(from, to, numberFftPoints, numberFftPoints >> 1);

        /**
         * Compute energy ("float") for each frequency point from the fft
         * ("complex")
         */
        if ((this.logBase2NumberFftPoints & 1) == 0) {
            for (int i = 0; i <= (numberFftPoints >> 1); i++) {
                output[i] = from[i].squaredMagnitudeComplex();
            }
        } else {
            for (int i = 0; i <= (numberFftPoints >> 1); i++) {
                output[i] = to[i].squaredMagnitudeComplex();
            }
        }
    }

    /**
     * Compute one stage in the FFT butterfly. The name "butterfly" appears
     * because this method computes elements in pairs, and a flowgraph of the
     * computation (output "0" comes from input "0" and "1" and output "1" comes
     * from input "0" and "1") resembles a butterfly.
     * <p/>
     * We r epeat <code>butterflyStage</code> for <b>log_2(numberFftPoints)</b>
     * stages, by calling the recursion with the argument
     * <code>currentDistance</code> divided by 2 at each call, and checking if
     * it's still > 0.
     *
     * @param from the input sequence at each stage
     * @param to the output sequence
     * @param numberFftPoints the total number of points
     * @param currentDistance the "distance" between elements in the butterfly
     */
    private void butterflyStage(Complex[] from,
            Complex[] to,
            int numberFftPoints,
            int currentDistance) {
        int ndx1From;
        int ndx2From;
        int ndx1To;
        int ndx2To;
        int ndxWeightFft;

        if (currentDistance > 0) {

            int twiceCurrentDistance = 2 * currentDistance;

            for (int s = 0; s < currentDistance; s++) {
                ndx1From = s;
                ndx2From = s + currentDistance;
                ndx1To = s;
                ndx2To = s + (numberFftPoints >> 1);
                ndxWeightFft = 0;
                while (ndxWeightFft < (numberFftPoints >> 1)) {
                    /**
                     * <b>weightFftTimesFrom2 = weightFft[k] </b> <b>
                     * *from[ndx2From]</b>
                     */
                    weightFftTimesFrom2.multiplyComplex(weightFft[ndxWeightFft], from[ndx2From]);
                    /**
                     * <b>to[ndx1To] = from[ndx1From] </b> <b> +
                     * weightFftTimesFrom2</b>
                     */
                    to[ndx1To].addComplex(from[ndx1From], weightFftTimesFrom2);
                    /**
                     * <b>to[ndx2To] = from[ndx1From] </b> <b> -
                     * weightFftTimesFrom2</b>
                     */
                    to[ndx2To].subtractComplex(from[ndx1From], weightFftTimesFrom2);
                    ndx1From += twiceCurrentDistance;
                    ndx2From += twiceCurrentDistance;
                    ndx1To += currentDistance;
                    ndx2To += currentDistance;
                    ndxWeightFft += currentDistance;
                }
            }

            /**
             * This call'd better be the last call in this block, so when it
             * returns we go straight into the return line below.
             *
             * We switch the <i>to</i> and <i>from</i> variables, the total
             * number of points remains the same, and the <i>currentDistance</i>
             * is divided by 2.
             */
            butterflyStage(to, from, numberFftPoints, (currentDistance >> 1));
        }
    }
    //**************************************************************************
    Main pMain;
    double shortVec[] = new double[FFTNo];
    double featureFreq[] = new double[FFTNo];
    int iter5 = 0;
    int iter500 = 0;
    boolean silent = false;
    double SPEC_RATIO = 1.1;
    double DecayRate = 0.996;
    double peakAvg = 0.0;
    double specSum = 0.0, avgSpecSum = 0.09, avgSpecMag = 100.0, minSpecSum = Double.MAX_VALUE;
    int count = 0;
    int pkNo = 5;
    boolean stable = false;

    public void setShortDiffAvg(double shortDiffAvg_) {
    }

    public void setMagThresh(double magThresh_) {
        SPEC_RATIO = magThresh_;
        // System.out.println("\nMag_Thresh: " + SPEC_RATIO);
    }

    public void setAED(Main aed_) {
        pMain = aed_;
    }
    int tcnt = 0;
    double logMean;
    double logVar;
    boolean RecBegin;
    LinkedList<Integer> userInput = new LinkedList<>();
    LinkedList<Integer> dataInput = new LinkedList<>();

//    class RecordDoneException extends Exception {
//
//        String str;
//
//        public RecordDoneException(String str) {
//            this.str = str;
//        }
//
//        public String getMessage() {
//            return (str);
//        }
//    }  
    public void voice_Process(double voice[]) { //1秒100次
        double shortSum = 0.0;
        double longSum = 0.0;
        double filt[] = new double[FFTNo];
        for (int i = 1; i < (FFTNo - 1); i++) {
            filt[i] = (voice[i - 1] + voice[i] + voice[i + 1]) / 3.0; //將每三個音訊做平均
        }
        for (int i = 0; i < FFTNo; i++) {
            shortVec[i] = shortVec[i] * 0.3 + filt[i] * 0.7; //short pattern
            shortSum += shortVec[i];
        }
        double logSum = 0.0;
        for (int i = 0; i < FFTNo; i++) {
            featureFreq[i] = 10.0 * Math.log10(shortVec[i] + 10.0); //分貝算式 算出分貝
            logSum += featureFreq[i];
        }
        logMean = logSum / ((double) FFTNo); //分貝平均值
        double varSum = 0.0, var = 0.0;
        for (int i = 0; i < 300; i++) { //只抓取前300
            var = Math.abs(featureFreq[i] - logMean); //前300個音頻和分貝平均值的差
            varSum += var;
        }
        logVar = varSum / 300.0; //平均標準差
        try {
            if (pMain.finishRec && pMain.binaryControl == 0) {
                voice_Store_User(userInput);
//                voice_Compare(); //開始音訊比對
//                userInput.clear();
                return;
            } else if (pMain.finishRec && pMain.binaryControl == 1) {
                voice_Store_DB(dataInput);
                System.out.println("長度" + dataInput.size());
                System.out.println("資料庫特徵" + dataInput.toString());
                dataInput.clear();
                return;
            }
            if (logVar < 8.0) { //提前判斷是否有聲音輸入，減少程式負擔
                if (pMain.binaryControl == 0) {//使用者輸入
                    soundCnt = 0;
                    if (!RecBegin) {//聲音還沒出現就先return
                        return;
                    }
                    userInput.offer(-1);//有聲音 但先中斷一下
                    tcnt++;
                    System.out.print(" -1");
                    if (tcnt > 99) {
                        cal = Calendar.getInstance();
                        System.out.print("\n" + cal.getTimeInMillis());
                        tcnt = 0;
                    }
                } else if (pMain.binaryControl == 1) {//資料庫輸入
                    soundCnt = 0;
                    if (!RecBegin) {
                        return;
                    }
                    dataInput.offer(-1);
                    tcnt++;
                    System.out.print(" -1");
                    if (tcnt > 99) {
                        cal = Calendar.getInstance();
                        System.out.print("\n" + cal.getTimeInMillis());
                        tcnt = 0;
                    }
                }
                return;
            }
            pMain.freqFr.updateSpec(featureFreq); //改變頻譜
            //----------------------------------------------------------------------
            getPeak(featureFreq);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
    LinkedList<boolean[]> storePeak = new LinkedList<>();
    Calendar cal = Calendar.getInstance();
    long minisec;
    int soundCnt = 0;

    public void getPeak(double featureFreq[]) { //取前面500個波峰2
        LinkedList<Integer> isPeak = new LinkedList<>();
//        double peak[] = new double[500];
        boolean arePeaks[] = new boolean[500];
//        System.arraycopy(featureFreq, 0, peak, 0, 500);//區間取樣，將區間複製到peak陣列裡(來源陣列，來源起始索引，目的陣列，目的起始索引，複製長度)
        for (int i = 1; i < 500 - 1; i++) {
            if (featureFreq[i] >= 7 && i >= 5) {
                if (featureFreq[i] > featureFreq[i - 1] && featureFreq[i] > featureFreq[i + 1]) { //若當前的頻率比前後頻率都高，就把它視為波峰 
                    isPeak.offer(i); //紀錄該波峰位置(數字)
                    arePeaks[i - 1] = true; //將判斷為是波峰的地方設為true
                    //isPeakValue.offer(featureFreq[i]); //該波峰的振幅 
                }
            }
        }
//        System.out.println("Peak:" + isPeak.toString());
        //----------------------------------------------------------------------
        storePeak.offer(arePeaks);
        while (storePeak.size() > 6) { //保留最後6個樣本
            storePeak.poll();
        }

        boolean finalPeak[] = new boolean[500]; //6個樣本最終
        int pkCnt[] = new int[500]; //負責將6個樣本內，前500個波峰的個數去做計算(ex.如果6個樣本內，有兩個樣本第8個位置是波峰，那pkCnt[8]=2
        for (boolean[] a : storePeak) { //計算前500個波峰個數
            for (int i = 0; i < 500; i++) {
                if (a[i]) {
                    pkCnt[i]++;
                }
            }
        }
        for (int i = 0; i < 500; i++) {
            if (pkCnt[i] > 2) {
                finalPeak[i] = true;
            }
        }
        int gapCount[] = new int[60]; //統計gap數量
        int prevP = 0, gap;
        for (int i = 0; i < 500; i++) {
            if (finalPeak[i]) {
                gap = i - prevP; //算出gap值，以此來判斷音階
                if (gap > 50) {
                    continue;
                }
                gapCount[gap]++; //怕有誤差，所以前後都加
                gapCount[gap - 1]++;
                gapCount[gap + 1]++;
                prevP = i;
            }
        }
        int maxGap = -1, maxId = -1;
        for (int i = 6; i < 60; i++) { //找出最大的gap數，就可以知道音階是多少
            if (gapCount[i] > maxGap) {
                maxGap = gapCount[i];
                maxId = i;
            }
        }
        if (userInput != null && pMain.binaryControl == 0) {//使用者
            soundCnt++;
            if (RecBegin || soundCnt > 5) {//有出現5次有聲音才開始將資料輸入
                RecBegin = true;//偵測出有聲音才打開布林
                userInput.offer(maxId);
            }
            tcnt++;
            System.out.print(" " + maxId);
            if (tcnt > 99) {
                cal = Calendar.getInstance();
                System.out.print("\n" + cal.getTimeInMillis());
                tcnt = 0;
            }
        } else if (dataInput != null && pMain.binaryControl == 1) {//資料庫
            soundCnt++;
            if (RecBegin || soundCnt > 5) {//有出現5次有聲音才開始將資料輸入
                RecBegin = true;//偵測出有聲音才打開布林
                dataInput.offer(maxId);
            }
            tcnt++;
            System.out.print(" " + maxId);
            if (tcnt > 99) {
                cal = Calendar.getInstance();
                System.out.print("\n" + cal.getTimeInMillis());
                tcnt = 0;
            }
        }
    }

    public void voice_Store_DB(LinkedList dataInput) {//用來儲存資料庫音樂特徵
        if (!dataInput.isEmpty()) { //若存取開關開啟
            //JSONArray jsonarray = JSONArray.fromObject(store);
            pMain.con.insert(dataInput);//將資料寫入DB
        } else {
            System.out.println("無音訊資料(資料庫存入)");
        }
    }
    LinkedList<String> allScale = new LinkedList<>();//存放所有資料庫資料(Scale)
    LinkedList<String> allSongName = new LinkedList<>();//存放所有資料庫資料(SongName)

    public int[] voice_Take_DB() {
//        String dbTake = "";
        if (allScale.isEmpty()) { //若allDBdata為空
            allScale = pMain.con.take_Scale(); //提取資料庫全部資料
            allSongName = pMain.con.take_Song_Name();
        }
        if (pMain.finishRec == true) { //若使用者結束錄製
            String dbInputStr = allScale.peek();
//            System.out.println(allScale.size()); //測試用
//            System.out.println("上面dbInputStr:" + dbInputStr); //測試用
            int DBwaitForCompare[] = get_TransferData(1, dbInputStr); //轉換一筆資料庫的資料供比對
            return DBwaitForCompare;
        } else {
            return null;
        }
    }

    public void voice_Store_User(LinkedList userInput) {//用來儲存使用者音樂特徵

        boolean opener = false;
        if (!userInput.isEmpty()) {
            opener = true;
        }
        if (opener == true) { //若存取開關開啟
            //JSONArray jsonarray = JSONArray.fromObject(store);
            opener = false;
        }
    }

    public int[] voice_Take_User() {
        String userInputStr = "";
        if (pMain.finishRec == true) {//若使用者結束錄製
            userInputStr = userInput.toString();
//            System.out.println("userInputStr:" + userInput); //測試用
            int USERwaitForCompare[] = get_TransferData(0, userInputStr); //轉換一筆資料庫的資料供比對
            return USERwaitForCompare;
        } else {
            return null;
        }
    }

    public int[] get_TransferData(int control, String str) { //只會轉換一筆(回傳轉換完成的數字陣列)
//        String x = dbcopy.pop();
        String strCopy = str;
        String rex = "", sub = "";
        if (control == 0) {//代表為User輸入
            rex = ", ";
            sub = strCopy.substring(1, strCopy.length() - 1);
        } else if (control == 1) {//代表為資料庫輸入
            rex = ",";
            sub = strCopy.substring(1, strCopy.length() - 1);
        }
//        System.out.println("sub:"+sub); //測試用
        String temS[] = sub.split(rex);
        int temI[] = new int[temS.length];
        for (int i = 0; i < temS.length; i++) { //將資料庫提出的資料轉為數字陣列
            temI[i] = Integer.parseInt(temS[i]);
        }
        return temI;
    }
    LinkedList<most_Similar> searchResult = new LinkedList<>();

    public void voice_Compare() {
        int[] USERwaitForCompare, DBwaitForCompare;
        if (voice_Take_User() == null) {
            JOptionPane.showMessageDialog(null, "使用者輸入失敗");
        } else if (voice_Take_DB() == null) {
            JOptionPane.showMessageDialog(null, "取得資料庫失敗");
        } else {
//            most_Similar unUse = new most_Similar();//用來儲存最長lcs的歌曲和地方
//            searchResult.offer(unUse);
            while (allScale.size() > 0) {
                System.out.println("userInput：" + userInput.size());
                System.out.println("dataInput：" + allScale.peek().length());
                USERwaitForCompare = voice_Take_User();
//                System.out.print("USERwaitForCompare：");
//                for (int i : USERwaitForCompare) {
//                    System.out.print(i + " ");
//                }
//                System.out.println();
                DBwaitForCompare = voice_Take_DB(); //此函示只會取第一筆資料庫資料來比對
//                System.out.print("DBwaitForCompare：");
//                for (int i : DBwaitForCompare) {
//                    System.out.print(i + " ");
//                }
//                System.out.println();
                int slideNum = 0;//儲存目前的位置
                int slideSize = (int) (USERwaitForCompare.length * 1.1); //去與本身1.1倍的特徵來比對
                most_Similar mostSimilar = new most_Similar();
                
                do { //滑軌判斷，為了確保最後一次也要執行才能進入迴圈判斷
                    if ((DBwaitForCompare.length - 1) - slideNum < slideSize) {
                        slideNum = (DBwaitForCompare.length - 1) - slideSize; //從後面擷取大小為slideNum的資料
                    }
                    int DBwaitForCompareSub[] = new int[slideSize]; //擷取部分資料庫資料，並將資料複製到陣列中
                    System.arraycopy(DBwaitForCompare, slideNum, DBwaitForCompareSub, 0, slideSize);//區間取樣，將區間複製到peak陣列裡(來源陣列，來源起始索引，目的陣列，目的起始索引，複製長度)
                    int console[][] = LCSLength(USERwaitForCompare, DBwaitForCompareSub);
                    LCS(console, USERwaitForCompare, USERwaitForCompare.length - 1, DBwaitForCompareSub.length - 1);
//                    System.out.println("使用者和資料庫的最長公共子序列是：" + LCS.toString());//顯示最長公共子序列
//                    double similar = ((double) LCS.size() / (double) (USERwaitForCompare.length - 1)) * 100;
                    if (LCS.size() > mostSimilar.lcsLength) { //若找到比儲存lcs長度還大的，就換儲存當前資料
                        mostSimilar.slideSize = slideSize;
                        mostSimilar.simliarStar = slideNum;
                        mostSimilar.lcsLength = LCS.size();
                        mostSimilar.songName = allSongName.peek();
                    }
                    LCS.clear(); //清除LCS內的暫存資料
//                    System.out.println("相似度:" + similar + "%");
                    slideNum += (int) (slideSize * 0.1); //排除先前比對的一半
                } while ((slideNum + slideSize) <= DBwaitForCompare.length);
                searchResult.offer(mostSimilar); //將該歌曲最相似的片段儲存
                allScale.poll();//比對完成就丟掉歌曲特徵
                allSongName.poll();//比對完成就丟掉歌曲名稱
            }
            SearchResult.resultStr = new String[searchResult.size()];
            SearchResult.resultTime = new int[searchResult.size()];
            int i = 0;
            for (most_Similar x : searchResult) {
                x.getAll();
                SearchResult.resultStr[i] = x.songName;
                SearchResult.resultTime[i]=(int)x.simliarStar/100;
//                System.out.println((int)x.simliarStar/100);
                i++;
            }
        }
    }

    class most_Similar {
        int slideSize;
        int simliarStar;
        int lcsLength = 0;
        String songName;

        public void getAll() {
            System.out.println("songName：" + songName + " simliarStar：" + (double) simliarStar / 100 + "s lcsLength：" + lcsLength);
        }
    }

    public int[][] LCSLength(int[] x, int[] y) {
        int m = x.length;
        int n = y.length;
        int[][] b = new int[x.length][y.length];
        int[][] c = new int[x.length][y.length];
        for (int i = 1; i < m; i++) {
            c[i][0] = 0;
        }
        for (int i = 1; i < n; i++) {
            c[0][i] = 0;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (x[i] == y[j]) {
                    c[i][j] = c[i - 1][j - 1] + 1;
                    b[i][j] = 1;
                } else if (c[i - 1][j] >= c[i][j - 1]) {
                    c[i][j] = c[i - 1][j];
                    b[i][j] = 2;
                } else {
                    c[i][j] = c[i][j - 1];
                    b[i][j] = 3;
                }
            }
        }
        return b;
    }
    LinkedList<Integer> LCS = new LinkedList<>();

    public void LCS(int[][] b, int[] x, int i, int j) {
        if (i == 0 || j == 0) {
            return;
        }
        if (b[i][j] == 1) {
            LCS(b, x, i - 1, j - 1);
//            System.out.print(x[i] + " "); //顯示最長公共子序列
            LCS.offer(x[i]);
        } else if (b[i][j] == 2) {
            LCS(b, x, i - 1, j);
        } else {
            LCS(b, x, i, j - 1);
        }
    }

}
